<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Borealis Storm</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Z-Index Stack */
        #skyCanvas { z-index: 0; }
        #auroraCanvas { z-index: 1; mix-blend-mode: screen; opacity: 0.95; }
        #rainCanvas { z-index: 2; pointer-events: none; }
        
        #flash {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #fff;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }

        /* UI */
        #ui-wrapper {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 20;
            pointer-events: none;
        }

        #ui-container {
            pointer-events: auto;
            background: rgba(8, 12, 16, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 40px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            display: flex;
            gap: 30px;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #ui-container.visible { 
            opacity: 1; 
            visibility: visible;
        }

        .control { display: flex; flex-direction: column; align-items: center; }
        
        .control label {
            color: #6d8a9f;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .scene-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #6d8a9f;
            font-size: 9px;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .scene-btn.active {
            background: rgba(79, 255, 221, 0.2);
            color: #4fd;
            border-color: #4fd;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 90px;
            height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #4fd;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #4fd;
            transition: transform 0.1s;
        }
        
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        /* Overlay */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: opacity 1.2s ease-out;
        }

        h1 {
            color: white;
            font-weight: 200;
            font-size: 3rem;
            letter-spacing: 8px;
            margin: 0 0 10px 0;
            text-shadow: 0 0 30px rgba(70, 255, 200, 0.4);
        }
        
        p { color: #666; letter-spacing: 2px; font-size: 0.9rem; }
    </style>
</head>
<body>

    <canvas id="skyCanvas"></canvas>
    <canvas id="auroraCanvas"></canvas>
    <canvas id="rainCanvas"></canvas>

    <div id="overlay">
        <h1>ETHER</h1>
        <p>Click to Initialize</p>
    </div>

    <div id="ui-wrapper">
        <div id="ui-container">
            <div class="control">
                <label>Scene</label>
                <div style="display: flex; gap: 8px;">
                    <div class="scene-btn active" onclick="setScene('aurora')">1</div>
                    <div class="scene-btn" onclick="setScene('nebula')">2</div>
                    <div class="scene-btn" onclick="setScene('resonance')">3</div>
                    <div class="scene-btn" onclick="setScene('bubbles')">4</div>
                    <div class="scene-btn" onclick="setScene('kaleidoscope')">5</div>
                    <div class="scene-btn" onclick="setScene('fireflies')">6</div>
                    <div class="scene-btn" onclick="setScene('ripples')">7</div>
                    <div class="scene-btn" onclick="setScene('rainSplash')">8</div>
                </div>
            </div>
            <div class="control">
                <label>Brightness</label>
                <input type="range" id="brightness" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="control">
                <label>Rain</label>
                <input type="range" id="vol" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="control">
                <label>Low Tone</label>
                <input type="range" id="lowTone" min="50" max="1500" value="300">
            </div>
            <div class="control">
                <label>High Tone</label>
                <input type="range" id="highTone" min="50" max="1500" value="700">
            </div>
            <div class="control">
                <label>Storm</label>
                <input type="range" id="storm" min="0" max="100" value="30">
            </div>
        </div>
    </div>

<script>
    // --- Audio Engine ---
    const UI = {
        vol: document.getElementById('vol'),
        lowTone: document.getElementById('lowTone'),
        highTone: document.getElementById('highTone'),
        storm: document.getElementById('storm'),
        brightness: document.getElementById('brightness')
    };

    let audioCtx, noiseBuffer, rainGain, rainFilter;
    let currentTone = 400;
    let toneVelocity = 0;

    function createPinkNoise(ctx) {
        const bSize = ctx.sampleRate * 5;
        const b = ctx.createBuffer(1, bSize, ctx.sampleRate);
        const d = b.getChannelData(0);
        let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
        for (let i = 0; i < bSize; i++) {
            const w = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + w * 0.0555179;
            b1 = 0.99332 * b1 + w * 0.0750759;
            b2 = 0.96900 * b2 + w * 0.1538520;
            b3 = 0.86650 * b3 + w * 0.3104856;
            b4 = 0.55000 * b4 + w * 0.5329522;
            b5 = -0.7616 * b5 - w * 0.0168980;
            d[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + w * 0.5362) * 0.11;
            b6 = w * 0.115926;
        }
        return b;
    }

    async function initAudio() {
        if (audioCtx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
        noiseBuffer = createPinkNoise(audioCtx);

        const src = audioCtx.createBufferSource();
        src.buffer = noiseBuffer;
        src.loop = true;

        rainFilter = audioCtx.createBiquadFilter();
        rainFilter.type = 'lowpass';
        rainFilter.frequency.value = currentTone;

        rainGain = audioCtx.createGain();
        rainGain.gain.value = UI.vol.value;

        src.connect(rainFilter).connect(rainGain).connect(audioCtx.destination);
        src.start();

        modulateRain();
        scheduleThunder();
    }

    function modulateRain() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const base = parseFloat(UI.vol.value);
        const target = Math.max(0, Math.min(1, base + (Math.random()*0.15 - 0.07)));
        rainGain.gain.setTargetAtTime(target, t, 3);
        setTimeout(modulateRain, 4000 + Math.random()*2000);
    }

    function triggerThunder() {
        if (!audioCtx) return;
        
        const t = audioCtx.currentTime;
        const dur = 4 + Math.random()*6;
        for(let i=0; i<3; i++) {
            const src = audioCtx.createBufferSource();
            src.buffer = noiseBuffer;
            src.loop = true;
            const f = audioCtx.createBiquadFilter();
            f.type = 'lowpass';
            f.frequency.value = 400; 
            f.frequency.exponentialRampToValueAtTime(30, t + dur);
            const g = audioCtx.createGain();
            g.gain.value = 0;
            const att = i * 0.5 + Math.random()*0.5;
            g.gain.linearRampToValueAtTime(0.3 + Math.random()*0.3, t + att);
            g.gain.exponentialRampToValueAtTime(0.001, t + att + dur);
            const p = audioCtx.createStereoPanner();
            p.pan.value = Math.random()*2 - 1;
            src.connect(f).connect(g).connect(p).connect(audioCtx.destination);
            src.start(t);
            src.stop(t + dur + 2);
        }
    }

    function scheduleThunder() {
        if (!audioCtx) return;
        const s = parseInt(UI.storm.value);
        if (s > 0) {
            const delay = 120000 / (s*1.2 + 1); 
            setTimeout(() => {
                if (Math.random() > 0.15) triggerThunder();
                scheduleThunder();
            }, delay * (0.5 + Math.random()));
        } else {
            setTimeout(scheduleThunder, 5000);
        }
    }

    UI.vol.addEventListener('input', e => rainGain && rainGain.gain.setTargetAtTime(e.target.value, audioCtx.currentTime, 0.1));

    let activeScene = 'aurora';
    function setScene(name) {
        activeScene = name;
        document.querySelectorAll('.scene-btn').forEach((btn, i) => {
            const scenes = ['aurora', 'nebula', 'resonance', 'bubbles', 'kaleidoscope', 'fireflies', 'ripples', 'rainSplash'];
            btn.classList.toggle('active', scenes[i] === name);
        });
    }

    // --- Visual Engine ---
    const cvs = {
        sky: document.getElementById('skyCanvas'),
        aurora: document.getElementById('auroraCanvas'),
        rain: document.getElementById('rainCanvas')
    };
    const ctx = {
        sky: cvs.sky.getContext('2d'),
        aurora: cvs.aurora.getContext('2d'),
        rain: cvs.rain.getContext('2d')
    };

    let w, h;
    function resize() {
        w = window.innerWidth;
        h = window.innerHeight;
        Object.values(cvs).forEach(c => { c.width = w; c.height = h; });
        stars = Array.from({length: Math.floor(w*h/4000)}, () => new Star());
        
        // Re-init nebula and bubbles on large resize
        if (typeof nebula !== 'undefined') nebula.init();
        if (typeof bubbles !== 'undefined') bubbles.init();
        if (typeof kaleidoscope !== 'undefined') kaleidoscope.init();
        if (typeof fireflies !== 'undefined') fireflies.init();
        if (typeof ripples !== 'undefined') ripples.init();
        if (typeof rainSplash !== 'undefined') rainSplash.init();
        
        drawSky();
    }
    window.addEventListener('resize', resize);

    let stars = [];
    class Star {
        constructor() {
            this.init();
            this.angle = Math.random() * Math.PI * 2;
        }
        init() {
            this.cx = w * 0.5;
            this.cy = -h * 0.2; 
            const distMax = Math.sqrt(w*w + h*h) * 1.2;
            this.r = Math.random() * distMax;
            this.size = Math.random() * 1.2;
            this.alpha = Math.random() * 0.8 + 0.2;
            this.speed = 0.00005 + Math.random() * 0.0001;
        }
        update() {
            this.angle += this.speed;
        }
        draw() {
            const x = this.cx + Math.cos(this.angle) * this.r;
            const y = this.cy + Math.sin(this.angle) * this.r;
            if (x < 0 || x > w || y < 0 || y > h * 0.9) return;
            const c = ctx.sky;
            const intensity = UI.brightness ? parseFloat(UI.brightness.value) : 1;
            c.globalAlpha = this.alpha * intensity;
            c.beginPath();
            c.arc(x, y, this.size, 0, Math.PI * 2);
            c.fill();
        }
    }

    function drawSky() {
        const c = ctx.sky;
        c.clearRect(0,0,w,h);
        const g = c.createRadialGradient(w/2, h, h*0.2, w/2, h, h*1.5);
        g.addColorStop(0, '#111520'); 
        g.addColorStop(0.5, '#040508');
        g.addColorStop(1, '#000000');
        c.fillStyle = g;
        c.fillRect(0,0,w,h);
        c.fillStyle = '#fff';
        stars.forEach(s => { 
            s.update(); 
            s.draw(); 
        });
    }

    // --- AURORA LOGIC ---
    class Aurora {
        constructor() { this.time = 0; }
        update() { this.time += 0.0025; }
        draw(intensity) {
            const c = ctx.aurora;
            if (intensity <= 0.01) return;
            c.globalCompositeOperation = 'lighter';

            const beams = 800;
            const cx = w/2;
            
            // CONFIGURATION:
            // scaleTop: 0.75 means top is 75% width of bottom (subtle taper)
            // yTop: -0.5 height means vanishing point is far above screen
            const scaleTop = 0.75; 
            const yTop = -h * 0.5; 
            
            for (let i = 0; i < beams; i++) {
                if (Math.random() > (0.15 + intensity * 0.8)) continue;

                const t = i / beams; // 0.0 to 1.0 along the curtain
                
                // Bottom Point calculation
                let bx = (t * w * 1.4) - (w * 0.2); 
                
                // Fold Logic
                bx += Math.sin(t * 12 + this.time) * (w * 0.1); 
                bx += Math.sin(t * 25 - this.time * 1.5) * (w * 0.04);

                let by = (h * 0.62) + Math.sin(t * 5 + this.time) * (h * 0.1);
                by += Math.sin(t * 15 - this.time * 0.8) * (h * 0.05);

                // Top Point Calculation (Perspective)
                // Move bx relative to center, scale it (taper), move back
                // With scaleTop 0.75, this is a much gentler inward slope
                let tx = (bx - cx) * scaleTop + cx;
                let ty = yTop; 

                // Jitter
                let jBy = by + (Math.random() * 80 - 40);
                let jTy = ty + (Math.random() * 150 - 50);

                // Color Gradient (Green to Purple)
                let hue = 150 + (t * 110);
                hue += Math.sin(this.time * 0.5) * 10;

                let alpha = (Math.random() * 0.12 + 0.02) * intensity;
                if(t<0.1) alpha *= t*10;
                if(t>0.9) alpha *= (1-t)*10;

                c.fillStyle = `hsla(${hue}, 85%, 60%, ${alpha})`;
                
                let bw = (Math.random() * 3 + 1) * (w/1200);
                
                c.beginPath();
                c.moveTo(bx - bw, jBy);
                c.lineTo(bx + bw, jBy);
                c.lineTo(tx + bw*scaleTop, jTy); 
                c.lineTo(tx - bw*scaleTop, jTy);
                c.fill();
            }
            c.globalCompositeOperation = 'source-over';
        }
    }
    const aurora = new Aurora();
    
    // --- NEBULA LOGIC ---
    class Nebula {
        constructor() {
            this.init();
        }
        init() {
            this.blobs = Array.from({length: 8}, () => ({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5) * 0.2,
                vy: (Math.random() - 0.5) * 0.2,
                size: Math.random() * (w * 0.4) + w * 0.2,
                hue: Math.random() * 60 + 200, // Blues and purples
                alpha: Math.random() * 0.2 + 0.1
            }));
        }
        update() {
            this.blobs.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
                if (b.x < -b.size) b.x = w + b.size;
                if (b.x > w + b.size) b.x = -b.size;
                if (b.y < -b.size) b.y = h + b.size;
                if (b.y > h + b.size) b.y = -b.size;
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            c.globalCompositeOperation = 'screen';
            this.blobs.forEach(b => {
                const g = c.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.size);
                g.addColorStop(0, `hsla(${b.hue}, 70%, 50%, ${b.alpha * intensity})`);
                g.addColorStop(1, 'transparent');
                c.fillStyle = g;
                c.fillRect(0, 0, w, h);
            });
            c.globalCompositeOperation = 'source-over';
        }
    }
    const nebula = new Nebula();

    // --- RESONANCE LOGIC ---
    class Resonance {
        constructor() {
            this.rings = Array.from({length: 5}, (_, i) => ({
                delay: i * 0.2,
                life: Math.random()
            }));
        }
        update() {
            this.rings.forEach(r => {
                r.life += 0.005;
                if (r.life > 1) r.life = 0;
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            // Map currentTone to a normalized value (e.g. 0.2 to 1.5)
            const low = parseFloat(UI.lowTone.value);
            const high = parseFloat(UI.highTone.value);
            const t = (currentTone - low) / (high - low || 1);
            
            c.strokeStyle = `hsla(${180 + t * 60}, 80%, 60%, ${0.3 * intensity})`;
            c.lineWidth = 2;
            
            this.rings.forEach(r => {
                const size = (r.life * h * 0.8) * (0.8 + t * 0.4);
                const alpha = Math.sin(r.life * Math.PI) * intensity * 0.5;
                c.beginPath();
                c.arc(w/2, h/2, size, 0, Math.PI * 2);
                c.strokeStyle = `hsla(${180 + t * 60}, 80%, 60%, ${alpha})`;
                c.lineWidth = 1 + t * 5;
                c.stroke();
                
                // Add a glow
                c.shadowBlur = 20 * t;
                c.shadowColor = `hsla(${180 + t * 60}, 80%, 60%, ${alpha})`;
            });
            c.shadowBlur = 0;
        }
    }
    const resonance = new Resonance();

    // --- BUBBLES LOGIC ---
    class Bubbles {
        constructor() {
            this.init();
        }
        init() {
            this.bubbles = Array.from({length: 40}, () => this.createBubble());
        }
        createBubble() {
            return {
                x: Math.random() * w,
                y: h + 50,
                r: Math.random() * 15 + 5,
                speed: Math.random() * 0.5 + 0.2,
                osc: Math.random() * Math.PI * 2,
                oscSpeed: Math.random() * 0.02 + 0.01
            };
        }
        update() {
            this.bubbles.forEach(b => {
                b.y -= b.speed;
                b.osc += b.oscSpeed;
                b.x += Math.sin(b.osc) * 0.3;
                if (b.y < -50) {
                    Object.assign(b, this.createBubble());
                }
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            c.strokeStyle = `rgba(255, 255, 255, ${0.2 * intensity})`;
            c.lineWidth = 1;
            this.bubbles.forEach(b => {
                c.beginPath();
                c.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                c.stroke();
                
                // Highlight
                c.beginPath();
                c.arc(b.x - b.r * 0.3, b.y - b.r * 0.3, b.r * 0.1, 0, Math.PI * 2);
                c.fillStyle = `rgba(255, 255, 255, ${0.1 * intensity})`;
                c.fill();
            });
        }
    }
    const bubbles = new Bubbles();
    
    // --- KALEIDOSCOPE LOGIC ---
    class Kaleidoscope {
        constructor() {
            this.time = 0;
            this.init();
        }
        init() {
            const diag = Math.sqrt(w*w + h*h);
            this.shapes = Array.from({length: 12}, () => ({
                size: Math.random() * (diag * 0.2) + diag * 0.1,
                dist: Math.random() * (diag * 0.5),
                speed: (Math.random() - 0.5) * 0.002,
                angle: Math.random() * Math.PI * 2,
                hue: Math.random() * 360,
                type: Math.random() > 0.5 ? 'arc' : 'rect',
                opacity: Math.random() * 0.1 + 0.05
            }));
        }
        update() {
            this.time += 0.002;
            this.shapes.forEach(s => s.angle += s.speed);
        }
        draw(intensity) {
            const c = ctx.aurora;
            const segments = 10;
            const step = (Math.PI * 2) / segments;
            
            c.save();
            c.translate(w/2, h/2);
            c.rotate(this.time * 0.1);

            for (let i = 0; i < segments; i++) {
                c.rotate(step);
                c.save();
                if (i % 2 === 0) c.scale(1, -1);
                
                this.shapes.forEach(s => {
                    const x = Math.cos(s.angle) * s.dist;
                    const y = Math.sin(s.angle) * s.dist;
                    const alpha = s.opacity * intensity;
                    
                    c.fillStyle = `hsla(${s.hue}, 40%, 30%, ${alpha})`;
                    c.strokeStyle = `hsla(${s.hue}, 40%, 50%, ${alpha * 1.5})`;
                    c.lineWidth = 1;
                    
                    c.beginPath();
                    if (s.type === 'arc') {
                        c.arc(x, y, s.size, 0, Math.PI * 0.5);
                        c.lineTo(x, y);
                    } else {
                        c.rect(x, y, s.size, s.size * 0.5);
                    }
                    c.fill();
                    c.stroke();
                });
                c.restore();
            }
            c.restore();
        }
    }
    const kaleidoscope = new Kaleidoscope();

    // --- FIREFLIES LOGIC ---
    class Fireflies {
        constructor() {
            this.init();
        }
        init() {
            this.flies = Array.from({length: 30}, () => ({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                life: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.02 + 0.01,
                size: Math.random() * 2 + 1
            }));
        }
        update() {
            this.flies.forEach(f => {
                f.x += f.vx + Math.sin(f.life) * 0.2;
                f.y += f.vy + Math.cos(f.life) * 0.2;
                f.life += f.speed;
                
                if (f.x < 0) f.x = w;
                if (f.x > w) f.x = 0;
                if (f.y < 0) f.y = h;
                if (f.y > h) f.y = 0;
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            this.flies.forEach(f => {
                const alpha = (Math.sin(f.life) * 0.5 + 0.5) * intensity;
                if (alpha <= 0) return;
                
                c.beginPath();
                const g = c.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size * 10);
                g.addColorStop(0, `rgba(255, 255, 150, ${alpha * 0.8})`);
                g.addColorStop(0.2, `rgba(255, 255, 100, ${alpha * 0.2})`);
                g.addColorStop(1, 'transparent');
                c.fillStyle = g;
                c.arc(f.x, f.y, f.size * 10, 0, Math.PI * 2);
                c.fill();
                
                c.beginPath();
                c.fillStyle = `rgba(255, 255, 200, ${alpha})`;
                c.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                c.fill();
            });
        }
    }
    const fireflies = new Fireflies();

    // --- RIPPLES LOGIC ---
    class Ripples {
        constructor() {
            this.init();
        }
        init() {
            this.ripples = [];
            this.timer = 0;
        }
        update() {
            this.timer++;
            if (this.timer % 60 === 0 && this.ripples.length < 10) {
                this.ripples.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    r: 0,
                    maxR: Math.random() * 100 + 50,
                    alpha: 1
                });
            }
            this.ripples.forEach((r, i) => {
                r.r += 0.5;
                r.alpha -= 0.005;
                if (r.alpha <= 0) this.ripples.splice(i, 1);
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            c.lineWidth = 1;
            this.ripples.forEach(r => {
                const alpha = r.alpha * intensity * 0.3;
                c.beginPath();
                c.strokeStyle = `rgba(200, 220, 255, ${alpha})`;
                c.arc(r.x, r.y, r.r, 0, Math.PI * 2);
                c.stroke();
                
                // Secondary subtle ripple
                if (r.r > 20) {
                    c.beginPath();
                    c.strokeStyle = `rgba(200, 220, 255, ${alpha * 0.5})`;
                    c.arc(r.x, r.y, r.r - 20, 0, Math.PI * 2);
                    c.stroke();
                }
            });
        }
    }
    const ripples = new Ripples();

    // --- RAIN SPLASH LOGIC ---
    class RainSplash {
        constructor() {
            this.init();
        }
        init() {
            this.drops = Array.from({length: 150}, () => this.createDrop());
            this.splashes = [];
        }
        createDrop() {
            // Perspective: splash point on the screen (y > h*0.4)
            const targetY = h * (0.4 + Math.random() * 0.6);
            // Perspective scale: things further away (lower targetY) are smaller/slower
            const scale = (targetY - h * 0.3) / (h * 0.7);
            
            return {
                x: Math.random() * w,
                y: Math.random() * -h,
                targetY: targetY,
                speed: (10 + Math.random() * 10) * scale,
                len: (10 + Math.random() * 20) * scale,
                scale: scale
            };
        }
        update() {
            this.drops.forEach(d => {
                d.y += d.speed;
                if (d.y > d.targetY) {
                    this.splashes.push({
                        x: d.x,
                        y: d.targetY,
                        r: 0,
                        alpha: 0.5 * d.scale,
                        maxR: 30 * d.scale,
                        scale: d.scale
                    });
                    Object.assign(d, this.createDrop());
                }
            });
            this.splashes.forEach((s, i) => {
                s.r += 0.5 * s.scale;
                s.alpha -= 0.01;
                if (s.alpha <= 0) this.splashes.splice(i, 1);
            });
        }
        draw(intensity) {
            const c = ctx.aurora;
            c.lineWidth = 1;
            this.drops.forEach(d => {
                c.strokeStyle = `rgba(200, 220, 255, ${0.3 * intensity * d.scale})`;
                c.beginPath();
                c.moveTo(d.x, d.y);
                c.lineTo(d.x, d.y + d.len);
                c.stroke();
            });
            this.splashes.forEach(s => {
                c.beginPath();
                // Perspective ellipse: wider than it is tall
                c.ellipse(s.x, s.y, s.r * 2, s.r * 0.5, 0, 0, Math.PI * 2);
                c.strokeStyle = `rgba(200, 220, 255, ${s.alpha * intensity})`;
                c.stroke();
            });
        }
    }
    const rainSplash = new RainSplash();

    // --- Rain ---
    class Drop {
        constructor() { this.reset(); this.y = Math.random()*h; }
        reset() {
            this.x = Math.random()*w;
            this.y = -20;
            this.z = Math.random(); 
            this.len = 15 + this.z*20;
            this.vel = 12 + this.z*12;
            this.col = `rgba(200, 230, 255, ${0.3 + this.z*0.4})`;
        }
        update() { this.y += this.vel; if(this.y>h) this.reset(); }
        draw() {
            const c = ctx.rain;
            const intensity = UI.brightness ? parseFloat(UI.brightness.value) : 1;
            c.beginPath(); 
            c.strokeStyle = `rgba(200, 230, 255, ${(0.3 + this.z*0.4) * intensity})`;
            c.lineWidth = 1 + this.z;
            c.moveTo(this.x, this.y); c.lineTo(this.x, this.y + this.len);
            c.stroke();
        }
    }
    const drops = Array.from({length: 500}, ()=>new Drop());

    function updateTone() {
        if (!audioCtx || !rainFilter) return;
        const low = parseFloat(UI.lowTone.value);
        const high = parseFloat(UI.highTone.value);
        
        // Bounded random walk - slowed down
        toneVelocity += (Math.random() - 0.5) * 0.4;
        toneVelocity *= 0.996; 
        currentTone += toneVelocity;
        
        const minT = Math.min(low, high);
        const maxT = Math.max(low, high);
        
        if (currentTone < minT) {
            currentTone = minT;
            toneVelocity *= -0.5; // Bounce off bound
        } else if (currentTone > maxT) {
            currentTone = maxT;
            toneVelocity *= -0.5;
        }
        
        rainFilter.frequency.setTargetAtTime(currentTone, audioCtx.currentTime, 0.1);
    }

    function loop() {
        drawSky();
        ctx.aurora.clearRect(0,0,w,h);
        ctx.rain.clearRect(0,0,w,h);
        
        updateTone();
        
        const brightness = parseFloat(UI.brightness.value);
        
        if (activeScene === 'aurora') {
            aurora.update();
            if(brightness > 0) aurora.draw(brightness);
        } else if (activeScene === 'nebula') {
            nebula.update();
            if(brightness > 0) nebula.draw(brightness);
        } else if (activeScene === 'resonance') {
            resonance.update();
            if(brightness > 0) resonance.draw(brightness);
        } else if (activeScene === 'bubbles') {
            bubbles.update();
            if(brightness > 0) bubbles.draw(brightness);
        } else if (activeScene === 'kaleidoscope') {
            kaleidoscope.update();
            if(brightness > 0) kaleidoscope.draw(brightness);
        } else if (activeScene === 'fireflies') {
            fireflies.update();
            if(brightness > 0) fireflies.draw(brightness);
        } else if (activeScene === 'ripples') {
            ripples.update();
            if(brightness > 0) ripples.draw(brightness);
        } else if (activeScene === 'rainSplash') {
            rainSplash.update();
            if(brightness > 0) rainSplash.draw(brightness);
        }
        
        drops.forEach(d => { d.update(); d.draw(); });
        requestAnimationFrame(loop);
    }

    resize();
    loop();

    document.getElementById('overlay').addEventListener('click', function() {
        this.style.opacity = 0;
        setTimeout(()=>this.style.display='none', 1200);
        initAudio();
        showUI();
    });

    // --- UI Auto-hide ---
    let uiTimeout;
    const uiContainer = document.getElementById('ui-container');

    function showUI() {
        uiContainer.classList.add('visible');
        clearTimeout(uiTimeout);
        uiTimeout = setTimeout(hideUI, 3000);
    }

    function hideUI() {
        if (!uiContainer.matches(':hover')) {
            uiContainer.classList.remove('visible');
        } else {
            // If mouse is hovering, check again in a bit
            uiTimeout = setTimeout(hideUI, 1000);
        }
    }

    window.addEventListener('mousemove', showUI);
    window.addEventListener('mousedown', showUI);
    window.addEventListener('touchstart', showUI);
</script>
</body>
</html>